[manifest]
version = "1.0.0"
dump_lua = true
priority = 0

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''v.ability.discarded = nil'''
position = 'after'
payload = '''if v.debuff then
    v.ability.temp_debuff = nil
    v:set_debuff()
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''G.FUNCS.play_cards_from_highlighted = function(e)'''
position = 'after'
payload = '''   played_hand = true'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''G.GAME.current_round.discards_left = math.max(0, G.GAME.round_resets.discards + G.GAME.round_bonus.discards)'''
position = 'before'
payload = '''if not G.GAME.modifiers["ante_hand_discard_reset"] or boss_ded then'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''G.GAME.current_round.hands_left = (math.max(1, G.GAME.round_resets.hands + G.GAME.round_bonus.next_hands))'''
position = 'after'
payload = '''elseif G.GAME.current_round.hands_left and (G.GAME.current_round.hands_left <= 0) then
    G.GAME.current_round.hands_left = 1
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''G.GAME.current_round.discards_left = math.max(0, G.GAME.round_resets.discards + G.GAME.round_bonus.discards)'''
position = 'before'
payload = '''if not G.GAME.modifiers["ante_hand_discard_reset"] then'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''G.GAME.current_round.hands_left = (math.max(1, G.GAME.round_resets.hands + G.GAME.round_bonus.next_hands))'''
position = 'after'
payload = '''end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''G.deck:hard_set_T()'''
position = 'after'
payload = '''local boss_ded = nil
if (G.GAME.round_resets.blind_states.Boss == 'Defeated') then
    boss_ded = true
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''function G.UIDEF.shop()'''
position = 'after'
payload = '''   if G.GAME.memory then
        return G.UIDEF.memory()
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''ease_hands_played(-self.hands_sub)'''
position = 'after'
payload = '''G.E_MANAGER:add_event(Event({
    trigger = 'immediate',
    func = function()
        if G.GAME.current_round.hands_left < 1 then
            G.GAME.current_round.hands_left = 1
        end
        return true
    end
}))'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''ease_discard(-self.discards_sub)'''
position = 'after'
payload = '''G.E_MANAGER:add_event(Event({
    trigger = 'immediate',
    func = function()
        if G.GAME.current_round.discards_left < 0 then
            G.GAME.current_round.discards_left = 1
        end
        return true
    end
}))'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = '''if v.ability.forced_selection and not self.highlighted[1] then'''
position = 'before'
payload = '''if v.ability.forced_selection and self.highlighted[1] and not v.highlighted then
    self:add_to_highlighted(v)
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''G.GAME.round_resets.blind_states.Small = 'Defeated''''
position = 'after'
payload = '''                        elseif G.GAME.blind_on_deck == 'Dungeon' then
                            '''
match_indent = false

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''elseif self.name == "Big Blind" then'''
position = 'before'
payload = '''elseif self.name == "The Dealer" then
    return 'Dungeon'
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''G.GAME.skips = (G.GAME.skips or 0) + 1'''
position = 'after'
payload = '''if _tag and _tag.config.ref_table then
    local valid = false
    if _tag.config.ref_table.key == 'tag_hit_blackjack' then
        valid = true
    elseif _tag.config.ref_table.key == 'tag_hit_memory' then
        valid = true
    end
    if valid then
        local skipped, skip_to = G.GAME.blind_on_deck or 'Small', 
        G.GAME.blind_on_deck == 'Small' and 'Big' or G.GAME.blind_on_deck == 'Big' and 'Boss' or 'Boss'
        G.GAME.round_resets.blind_states[skipped] = 'Skipped'
        G.GAME.round_resets.blind_states[skip_to] = 'Select'
        G.GAME.blind_on_deck = skip_to
        play_sound('generic1')
        G.E_MANAGER:add_event(Event({
            trigger = 'immediate',
            func = function()
            delay(0.3)
            if SMODS.calculate_context then
                SMODS.calculate_context({skip_blind = true})
            else
                for i = 1, #G.jokers.cards do
                    G.jokers.cards[i]:calculate_joker({skip_blind = true})
                end
                save_run()
                for i = 1, #G.GAME.tags do
                    G.GAME.tags[i]:apply_to_run({type = 'immediate'})
                end
                for i = 1, #G.GAME.tags do
                    if G.GAME.tags[i]:apply_to_run({type = 'new_blind_choice'}) then break end
                end
            end
            if _tag.config.ref_table.key == 'tag_hit_memory' then
                if G.blind_select then 
                    G.blind_prompt_box:get_UIE_by_ID('prompt_dynatext1').config.object.pop_delay = 0
                    G.blind_prompt_box:get_UIE_by_ID('prompt_dynatext1').config.object:pop_out(5)
                    G.blind_prompt_box:get_UIE_by_ID('prompt_dynatext2').config.object.pop_delay = 0
                    G.blind_prompt_box:get_UIE_by_ID('prompt_dynatext2').config.object:pop_out(5) 
            
                    G.E_MANAGER:add_event(Event({
                    trigger = 'before', delay = 0.2,
                    func = function()
                        G.blind_prompt_box.alignment.offset.y = -10
                        G.blind_select.alignment.offset.y = 40
                        G.blind_select.alignment.offset.x = 0
                        return true
                    end}))
                    G.E_MANAGER:add_event(Event({
                    trigger = 'immediate',
                    func = function()
                        G.blind_select:remove()
                        G.blind_prompt_box:remove()
                        G.blind_select = nil
                        delay(0.2)
                        return true
                    end}))
                    G.E_MANAGER:add_event(Event({
                    trigger = 'immediate',
                    func = function()
                        G.RESET_JIGGLES = nil
                        delay(0.4)
                        G.E_MANAGER:add_event(Event({
                        trigger = 'immediate',
                        func = function()
                            
                            delay(0.4)

                            G.E_MANAGER:add_event(Event({
                                trigger = 'immediate',
                                func = function()
                                    G.GAME.memory = true
                                    G.STATE = G.STATES.SHOP
                                    G.STATE_COMPLETE = false
                                    return true
                                end
                            }))
                            return true
                            end
                        }))
                        return true
                        end
                    }))
                end
            end
            return true
            end
        }))
        return
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''config.saved and'''
position = 'after'
payload = '''(G and G.GAME and G.GAME.blind and G.GAME.blind.config and G.GAME.blind.config.blind and G.GAME.blind.config.blind.name == "The Dealer") and {n=G.UIT.C, config={padding = 0.05, align = 'cm'}, nodes={
    {n=G.UIT.R, config={align = 'cm'}, nodes={
        {n=G.UIT.O, config={object = DynaText({string = {' '..localize('ph_blackjack_lost')..' '}, colours = {G.C.RED}, shadow = true, pop_in = 0, scale = 0.5*scale, silent = true})}}
    }}
}} or config.saved and'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''function Card:highlight(is_higlighted)'''
position = 'after'
payload = '''   if G.memory_row_1 and ((self.area == G.memory_row_1) or (self.area == G.memory_row_2)) then
        if (self.facing == 'back') and G.GAME.currently_choosing and G.GAME.memory_cards and not self.debuff then
            self:flip()
            table.insert(G.GAME.memory_cards, self)
            if #G.GAME.memory_cards == 2 then
                local match = nil
                if G.GAME.memory_cards[1].config.center.key == G.GAME.memory_cards[2].config.center.key then
                    play_area_status_text("Match")
                    match = G.GAME.memory_cards[1].config.center.key
                end
                local cards = G.GAME.memory_cards
                G.GAME.memory_cards = nil
                G.E_MANAGER:add_event(Event({
                    trigger = 'immediate',
                    func = function()
                        G.E_MANAGER:add_event(Event({
                            trigger = 'after',
                            delay = 3,
                            func = function()
                                if match then
                                    cards[1].ability.perma_debuff = true
                                    cards[2].ability.perma_debuff = true
                                    if cards[1].ability.consumeable and (G.consumeables.config.card_limit > #G.consumeables.cards) then
                                        local card = SMODS.create_card {key = match, area = G.consumeables}
                                        card:add_to_deck()
                                        G.consumeables:emplace(card)
                                    elseif cards[1].ability.set == "Joker" and (G.jokers.config.card_limit > #G.jokers.cards) then
                                        local card = SMODS.create_card {key = match, area = G.jokers}
                                        card:add_to_deck()
                                        G.jokers:emplace(card)
                                    elseif cards[1].ability.set == "Voucher" then
                                        local card = SMODS.create_card {key = match}
                                        G.FUNCS.use_card({config = {ref_table = card}})
                                    end
                                else
                                    cards[1]:flip()
                                    cards[2]:flip()
                                end
                                G.GAME.currently_choosing = nil
                                save_run()
                                return true
                            end}))
                        return true
                    end
                }))
            end
        end
        return
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''self.load_shop_vouchers = nil'''
position = 'after'
payload = '''G.load_memory_row_1 = nil
G.load_memory_row_2 = nil'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''G.CONTROLLER.locks.toggle_shop = true'''
position = 'after'
payload = '''G.GAME.memory = nil'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''self.config.blind = blind or {}'''
position = 'after'
payload = '''if G.GAME.modifiers.dungeon then
    G.GAME.hit_busted = nil
    G.GAME.hit_limit = 2
    for i = #G.enemy_deck.cards, 1, -1 do
        if G.enemy_deck.cards[i] and not G.enemy_deck.cards[i].removed then G.enemy_deck.cards[i]:remove() end
    end
    for i = #G.enemy_discard.cards, 1, -1 do
        if G.enemy_discard.cards[i] and not G.enemy_discard.cards[i].removed then G.enemy_discard.cards[i]:remove() end
    end
    local suits = {'H', 'S', 'D', 'C'}
    local ranks = {'2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'}
    local cards = {}
    local power = (not G.GAME.modifiers.scaling and 1 or (G.GAME.modifiers.scaling == 1) and 1 or (G.GAME.modifiers.scaling == 2) and 1.25 or (G.GAME.modifiers.scaling == 3) and 1.5) * (10 * (G.GAME.round_resets.ante))
    local stones = 0
    if (blind and blind.name or '') == "The Goad" then
        suits = {'H', 'D', 'C'}
    elseif (blind and blind.name or '') == "The Club" then
        suits = {'H', 'D', 'S'}
    elseif (blind and blind.name or '') == "The Head" then
        suits = {'C', 'D', 'S'}
    elseif (blind and blind.name or '') == "The Window" then
        suits = {'C', 'H', 'S'}
    elseif (blind and blind.name or '') == "The Plant" then
        ranks = {'2', '3', '4', '5', '6', '7', '8', '9', 'T', 'A'}
    elseif (blind and blind.name or '') == "Violet Vessel" then
        stones = 10
    elseif (blind and blind.name or '') == "Crimson Heart" then
        suits = {'H', 'H', 'H', 'H'}
    elseif (blind and blind.name or '') == "Verdant Leaf" then
        if G.GAME.hit_bust_limit and (G.GAME.hit_bust_limit >= 31) then
            ranks = {'8', '8', '8', '8', '8', '8', '8', '8', '8', '7', '7', '7', '7'}
        elseif G.GAME.hit_bust_limit and (G.GAME.hit_bust_limit == 20) then
            ranks = {'7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '6', '6', '6'}
        else
            ranks = {'7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '8', '8', '8'}
        end
        power = 0
    elseif (blind and blind.name or '') == "Amber Acorn" then
        for i = 1, 52 do
            local rank = pseudorandom_element(ranks, pseudoseed('acorn'))
            local suit = pseudorandom_element(suits, pseudoseed('acorn'))
            table.insert(cards, {suit, rank, 'c_base'})
        end
        ranks = {}
        suits = {}
    end
    if (blind and blind.name or '') == "Small Blind" then
        power = power - 20
    elseif (blind and blind.name or '') ~= "Big Blind" then
        power = power
    else
        power = power + 25
    end
    if power < 0 then
        power = 0
    end
    for _, i in ipairs(suits) do
        for _, j in ipairs(ranks) do
            table.insert(cards, {i, j, 'c_base'})
        end
    end
    for i = 1, stones do
        table.insert(cards, {'H', 'A', 'm_stone'})
    end
    local fails = 0
    while (power > 0) and (fails < 5) do
        local index = 1 + math.floor(#cards * pseudorandom('enemy_deck_card'))
        if cards[index] then
            local card = cards[index]
            local pool = {}
            local rank_class = 1
            if (card[2] == '3') or (card[2] == '7') or (card[2] == '8') or (card[2] == '9') then
                rank_class = 2
                table.insert(pool, {'rise', 4})
            elseif (card[2] == 'T') or (card[2] == 'J') or (card[2] == 'Q') or (card[2] == 'K') or (card[2] == 'A') then
                rank_class = 3
                if (card[2] ~= 'A') then
                    table.insert(pool, {'bump', 2})
                end
            else
                table.insert(pool, {'rise2', 8})
            end
            local enhancement_class = 0
            if (card[3] == 'm_bonus') or (card[3] == 'm_mult') then
                enhancement_class = 1
                table.insert(pool, {'enhance2', 10})
            elseif (card[3] == 'm_lucky') or (card[3] == 'm_glass') or (card[3] == 'm_stone') then
                enhancement_class = 2
            elseif (card[3] == 'c_base') then
                table.insert(pool, {'enhance1', 5})
            end
            local new_pool = {}
            for i, j in ipairs(pool) do
                if power >= j[2] then
                    table.insert(new_pool, j)
                end
            end
            pool = new_pool
            if #pool > 0 then
                if power >= pool[1][2] then
                    power = power - pool[1][2]
                    fails = 0
                    if pool[1][1] == 'rise' then
                        card[2] = pseudorandom_element({'3', '7', '8', '9'}, pseudoseed('power'))
                    elseif pool[1][1] == 'rise2' then
                        if (blind and blind.name or '') == "Crimson Heart" then
                            card[2] = 'K'
                        else
                            card[2] = pseudorandom_element({'T', 'J', 'Q', 'K', 'A'}, pseudoseed('power'))
                        end
                    elseif pool[1][1] == 'bump' then
                        if card[2] == 'T' then
                            card[2] = 'J'
                        elseif card[2] == 'J' then
                            card[2] = 'Q'
                        elseif card[2] == 'Q' then
                            card[2] = 'K'
                        elseif card[2] == 'K' then
                            card[2] = 'A'
                        end
                    elseif pool[1][1] == 'enhance1' then
                        card[3] = pseudorandom_element({'m_bonus', 'm_mult'}, pseudoseed('power'))
                    elseif pool[1][1] == 'enhance2' then
                        card[3] = pseudorandom_element({'m_lucky', 'm_glass', 'm_stone'}, pseudoseed('power'))
                    end
                else
                    fails = fails + 1
                end
            else
                fails = fails + 1
            end
        else
            fails = fails + 1
        end
    end
    for i = 1, #cards do
        local _card = Card(G.enemy_deck.T.x, G.enemy_deck.T.y, G.CARD_W, G.CARD_H, G.P_CARDS[cards[i][1] .. '_' .. cards[i][2]], G.P_CENTERS[cards[i][3]], {})
        _card.ability.enemy = true
        G.enemy_deck:emplace(_card)
    end
    G.enemy_deck:shuffle('enemy_deck')
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''function Blind:drawn_to_hand()'''
position = 'after'
payload = '''   if G.GAME.modifiers.dungeon then
        G.GAME.negate_hand = nil
        check_total_over_21()
        if ((#G.deck.cards == 0) and (#G.hand.cards == 0)) and not (G.GAME.hit_reshuffle_deck and (#G.discard.cards >= 0)) then
            end_round()
        else
            if G.GAME.forced_stand then
                G.GAME.forced_stand = nil
                G.GAME.blind:set_text()
                G.GAME.blind:wiggle()
                G.FUNCS.stand()
                G.STATE = G.STATES.HAND_PLAYED
                G.STATE_COMPLETE = true
            end
        end
        G.GAME.last_round_drawn = G.GAME.round
    end'''
match_indent = true 

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''for i=1, #cards_destroyed do'''
position = 'before'
payload = '''if G.GAME.negate_hand then
    mult = G.GAME.negate_hand * mult
    G.GAME.negate_hand = nil
    G.E_MANAGER:add_event(Event({
        trigger = 'before',
        delay = 0.8,
        func = function()
            G.GAME.current_round.current_hand.mult = tostring(mult)
            G.hand_text_area.mult:update(0)
            return true
        end
    }))
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''ease_hands_played(-1)'''
position = 'at'
payload = '''if not G.GAME.modifiers.dungeon then
    ease_hands_played(-1)
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = '''function CardArea:add_to_highlighted(card, silent)'''
position = 'after'
payload = '''   if (self == G.hand) and G.GAME and G.GAME.modifiers and G.GAME.modifiers.dungeon then
        self.config.highlighted_limit = 1000000
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = '''if #self.cards < self.config.card_limit or self == G.deck or self == G.hand then'''
position = 'at'
payload = '''if #self.cards < self.config.card_limit or self == G.deck or self == G.hand or ((self == G.play) and G.GAME and G.GAME.modifiers and G.GAME.modifiers.dungeon) then'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''   label = localize('b_full_deck'),
    tab_definition_function = G.UIDEF.view_deck
},'''
position = 'after'
payload = '''G.GAME.modifiers.dungeon and {
            label = localize('b_enemy_deck'),
            tab_definition_function = G.UIDEF.view_enemy_deck
        },'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''self.discard = CardArea('''
position = 'before'
payload = '''self.enemy_deck = CardArea(
    0, 0,
    CAI.deck_W,CAI.deck_H,
    {card_limit = 520, type = 'deck'})

self.enemy_discard = CardArea(
    0, 0,
    CAI.discard_W,CAI.discard_H,
    {card_limit = 500, type = 'discard'})'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''G.deck.T.x = G.TILE_W - G.deck.T.w - 0.5'''
position = 'before'
payload = '''G.enemy_deck.T.x = G.TILE_W - G.enemy_deck.T.w - 0.5 + 3*G.CARD_W
G.enemy_deck.T.y = G.TILE_H - G.enemy_deck.T.h
G.enemy_discard.T.x = G.jokers.T.x + G.jokers.T.w/2 + 0.3 + 15
G.enemy_discard.T.y = 4.2'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''local nosave_shop = nil'''
position = 'after'
payload = '''local old_shop_exists = shop_exists
if G.GAME.modifiers.dungeon and G.GAME.memory then
    shop_exists = true
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''G.CONTROLLER:snap_to({node = G.shop:get_UIE_by_ID('next_round_button')})'''
position = 'before'
payload = '''shop_exists = old_shop_exists
if not shop_exists and G.GAME.modifiers.dungeon and G.shop_jokers and G.GAME.memory then
    if G.load_shop_jokers then 
        nosave_shop = true
        G.shop_jokers:load(G.load_shop_jokers)
        for k, v in ipairs(G.shop_jokers.cards) do
            create_shop_card_ui(v)
            if v.ability.consumeable then v:start_materialize() end
            for _kk, vvv in ipairs(G.GAME.tags) do
                if vvv:apply_to_run({type = 'store_joker_modify', card = v}) then break end
            end
        end
        G.load_shop_jokers = nil
    elseif not G.GAME.first_shop_buffoon and not G.GAME.banned_keys['p_buffoon_normal_1'] then
        G.GAME.first_shop_buffoon = true
        local card = Card(G.shop_jokers.T.x + G.shop_jokers.T.w/2,
        G.shop_jokers.T.y, G.CARD_W*1.27, G.CARD_H*1.27, G.P_CARDS.empty, G.P_CENTERS['p_buffoon_normal_'..(math.random(1, 2))], {bypass_discovery_center = true, bypass_discovery_ui = true})
        create_shop_card_ui(card, 'Booster', G.shop_jokers)
        card.ability.booster_pos = #G.shop_jokers.cards + 1
        card:start_materialize()
        G.shop_jokers:emplace(card)
        card.ability.couponed = true
        card:set_cost()
        create_shop_card_ui(card, card.ability.set, G.shop_jokers)
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''if G.SETTINGS.paused then dt = 0 end'''
position = 'after'
payload = '''if G.GAME.suits_drawn then
    G.GAME.chips = 0
end
if G and G.GAME and G.GAME.modifiers and G.GAME.modifiers.dungeon and G.hand and G.hand.highlighted then
    if (#G.hand.highlighted == 1) and G.GAME.current_round and G.GAME.current_round.discards_left and (G.GAME.current_round.discards_left > 0) then
        G.GAME.hit_discard_button = localize('b_discard')
    else
        G.GAME.hit_discard_button = localize('b_hit')
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''G.FUNCS.discard_cards_from_highlighted = function(e, hook)'''
position = 'after'
payload = '''   if G.GAME.modifiers.dungeon then
    G.GAME.hit_limit = #G.hand.cards - 1
    if G.GAME.hit_limit < 1 then
        G.GAME.hit_limit = 1
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''function Card:calculate_joker(context)'''
position = 'after'
payload = '''   if G.GAME.modifiers.dungeon and context.first_hand_drawn then
    if G.GAME.last_round_drawn == G.GAME.round then
        context.first_hand_drawn = nil
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''v.ability.discarded = nil'''
position = 'after'
payload = '''if v.ability.revert_base then
    if v.ability.revert_base[2] > 1 then
        v.ability.revert_base[2] = v.ability.revert_base[2] - 1
    else
        v:set_base(v.ability.revert_base[1])
        G.GAME.blind:debuff_card(v)
        v.ability.revert_base = nil
    end
end
v.ability.hit_hermit_indicator = nil
v.ability.hit_moon_indicator = nil
v.ability['4_W_uses'] = nil
G.GAME.suits_drawn = nil'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''G.deck:shuffle('nr'..G.GAME.round_resets.ante)'''
position = 'after'
payload = '''for i = 1, #G.deck.cards do
    if G.deck.cards[i].ability and G.deck.cards[i].ability.shuffle_bottom then
        G.deck.cards[i].ability.hit_hermit_indicator = G.deck.cards[i].ability.shuffle_bottom
        G.deck.cards[i].ability.shuffle_bottom = G.deck.cards[i].ability.shuffle_bottom - 1
        if G.deck.cards[i].ability.shuffle_bottom == 0 then
            G.deck.cards[i].ability.shuffle_bottom = nil
        end
        local card = G.deck.cards[i]
        table.remove(G.deck.cards, i)
        table.insert(G.deck.cards, 1, card)
    end
    G.deck:set_ranks()
end
for i = #G.deck.cards, 1, -1 do
    if G.deck.cards[i].ability and G.deck.cards[i].ability.shuffle_top then
        G.deck.cards[i].ability.hit_moon_indicator = G.deck.cards[i].ability.shuffle_top
        G.deck.cards[i].ability.shuffle_top = G.deck.cards[i].ability.shuffle_top - 1
        if G.deck.cards[i].ability.shuffle_top == 0 then
            G.deck.cards[i].ability.shuffle_top = nil
        end
        local card = G.deck.cards[i]
        table.remove(G.deck.cards, i)
        table.insert(G.deck.cards, card)
    end
    G.deck:set_ranks()
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''--Fill all remaining info if this is the main desc'''
position = 'before'
payload = '''if card and card.ability and card.ability.hit_hermit_indicator then info_queue[#info_queue+1] = {key = 'hit_hermit_indicator', set = 'Other', vars = {card.ability.hit_hermit_indicator}} end
if card and card.ability and card.ability.shuffle_bottom and not card.ability.hit_hermit_indicator then info_queue[#info_queue+1] = {key = 'hit_hermit_indicator', set = 'Other', vars = {card.ability.shuffle_bottom}} end
if card and card.ability and card.ability.hit_moon_indicator then info_queue[#info_queue+1] = {key = 'hit_moon_indicator', set = 'Other', vars = {card.ability.hit_moon_indicator}} end
if card and card.ability and card.ability.shuffle_top and not card.ability.hit_moon_indicator then info_queue[#info_queue+1] = {key = 'hit_moon_indicator', set = 'Other', vars = {card.ability.shuffle_top}} end
if card and card.ability and card.ability.revert_base then info_queue[#info_queue+1] = {key = 'revert_base', set = 'Other', vars = {localize(card.ability.revert_base[1].value, 'ranks'), localize(card.ability.revert_base[1].suit, 'suits_plural'), card.ability.revert_base[2]}} end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''{string = 'rand()', colour = G.C.JOKER_GREY},{string = "#@"..(G.deck and G.deck.cards[1] and G.deck.cards[#G.deck.cards].base.id or 11)..(G.deck and G.deck.cards[1] and G.deck.cards[#G.deck.cards].base.suit:sub(1,1) or 'D'), colour = G.C.RED},'''
position = 'at'
payload = '''{string = 'rand()', colour = G.C.JOKER_GREY},{string = "#@NO", colour = G.C.RED},'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''local config = {}'''
position = 'before'
payload = '''if card.area == G.enemy_deck then
    y_off = -0.05*G.CARD_H
    card_aligned = 'tm'
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''local run_info_colour = run_info and (blind_state == 'Defeated' and G.C.GREY or blind_state == 'Skipped' and G.C.BLUE or blind_state == 'Upcoming' and G.C.ORANGE or blind_state == 'Current' and G.C.RED or G.C.GOLD)'''
position = 'after'
payload = '''local extra_dollars_mod = nil
if G.GAME.modifiers and G.GAME.modifiers.dungeon then
    local stand_val = (G.GAME.hit_bust_limit or 21) - 4
    if obj.get_stand_val then
        stand_val = obj:get_stand_val()
    elseif obj.name == "Small Blind" then
        stand_val = (G.GAME.hit_bust_limit or 21) - 6
    end
    blind_desc_nodes[#blind_desc_nodes+1] = {n=G.UIT.R, config={align = "cm", maxw = 2.8}, nodes={
        {n=G.UIT.T, config={text = localize {type = 'variable', key = 'stands_on', vars = {stand_val}}, scale = 0.32, colour = disabled and G.C.UI.TEXT_INACTIVE or G.C.UI.TEXT_LIGHT, shadow = not disabled}}
    }}
    text_table[1] = true
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''if loc_target then'''
position = 'before'
payload = '''if G.GAME.modifiers and G.GAME.modifiers.dungeon then
    local obj = self.config.blind
    local stand_val = (G.GAME.hit_bust_limit or 21) - 4
    if obj.get_stand_val then
        stand_val = obj:get_stand_val()
    elseif obj.name == "Small Blind" then
        stand_val = (G.GAME.hit_bust_limit or 21) - 6
    end
    table.insert(loc_target, localize {type = 'variable', key = 'stands_on', vars = {stand_val}})
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''if self.ability.set == "Joker" and not self.debuff then'''
position = 'before'
payload = '''if ((self.ability.name == 'Ride the Bus') or (self.ability.name == 'Obelisk')) and context.before and (context.cardarea == G.jokers) and ((G.GAME.negate_hand or 1) < 0) then
    return nil 
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''self.triggered = blindTable.triggered'''
position = 'after'
payload = '''self.hits = blindTable.hits'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''hands = self.hands,'''
position = 'after'
payload = '''hits = self.hits,'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''self.highlighted = is_higlighted'''
position = 'after'
payload = '''if self.playing_card and not self.children.use_button then
        if self.highlighted and self.area and self.area == G.consumeables then
        local x_off = (self.ability.consumeable and -0.1 or 0)
        self.children.use_button = UIBox{
            definition = G.UIDEF.use_and_sell_buttons(self), 
            config = {align=
                    ((self.area == G.jokers) or (self.area == G.consumeables)) and "cr" or
                    "bmi"
                , offset = 
                    ((self.area == G.jokers) or (self.area == G.consumeables)) and {x=x_off - 0.4,y=0} or
                    {x=0,y=0.65},
                parent =self}
        }
    elseif self.children.use_button then
        self.children.use_button:remove()
        self.children.use_button = nil
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''if card.area and card.area.config.type == 'joker' then'''
position = 'before'
payload = '''if card.area and (card.area == G.consumeables) and card.playing_card then
    use = 
    {n=G.UIT.C, config={align = "cr"}, nodes={
      {n=G.UIT.C, config={ref_table = card, align = "cr",maxw = 1.25, padding = 0.1, r=0.08, minw = 1.25, minh = 1, hover = true, shadow = true, colour = G.C.UI.BACKGROUND_INACTIVE, one_press = true, button = 'hit_use_minor_arcana', func = 'hit_can_use_minor_arcana'}, nodes={
        {n=G.UIT.B, config = {w=0.1,h=0.6}},
        {n=G.UIT.T, config={text = localize('b_use'),colour = G.C.UI.TEXT_LIGHT, scale = 0.55, shadow = true}}
      }}
    }}
    sell =
    {n=G.UIT.C, config={align = "cr"}, nodes={
      {n=G.UIT.C, config={ref_table = card, align = "cr",maxw = 1.25, padding = 0.1, r=0.08, minw = 1.25, minh = 1, hover = true, shadow = true, colour = G.C.UI.BACKGROUND_INACTIVE, one_press = true, button = 'hit_discard_minor_arcana', func = 'hit_can_discard_minor_arcana'}, nodes={
        {n=G.UIT.B, config = {w=0.1,h=0.6}},
        {n=G.UIT.T, config={text = localize('b_discard'),colour = G.C.UI.TEXT_LIGHT, scale = 0.55, shadow = true}}
      }}
    }}
    local t = {
      n=G.UIT.ROOT, config = {padding = 0, colour = G.C.CLEAR}, nodes={
        {n=G.UIT.C, config={padding = 0.15, align = 'cl'}, nodes={
          {n=G.UIT.R, config={align = 'cl'}, nodes={
            sell
          }},
          {n=G.UIT.R, config={align = 'cl'}, nodes={
            use
          }},
        }},
    }}
    return t
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''G.RESET_BLIND_STATES = true'''
position = 'after'
payload = '''local delete_these = {}
for i = 1, #G.playing_cards do
    if G.playing_cards[i].ability.fleeting then
        table.insert(delete_these, G.playing_cards[i])
    end
end
for i = 1, #delete_these do
    delete_these[i]:remove()
end
local pool = {}
for i = 1, #G.consumeables.cards do
    table.insert(pool, G.consumeables.cards[i])
end
for i = 1, #pool do
    if pool[i].config.card and hit_minor_arcana_suits[pool[i].config.card.suit] then
        draw_card(G.consumeables,G.deck, 90,'down', nil, pool[i])
    end
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''--Fill all remaining info if this is the main desc'''
position = 'before'
payload = '''if card and card.ability and card.ability.fleeting then info_queue[#info_queue+1] = {key = 'fleeting', set = 'Other'} end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''function copy_card(other, new_card, card_scale, playing_card, strip_edition)'''
position = 'after'
payload = '''   local old_fleeting_hit = other.ability and other.ability.fleeting or nil
    if new_card and new_card.ability then
        old_fleeting_hit = new_card.ability.fleeting
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''new_card:set_sprites(new_card.config.center)'''
position = 'before'
payload = '''new_card.ability.fleeting = old_fleeting_hit'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''if main_start then 
    desc_nodes[#desc_nodes+1] = main_start 
end'''
position = 'after'
payload = '''if card and card.config.card and hit_minor_arcana_suits[card.config.card.suit] then
    local vars = hit_minor_arcana_loc_vars(card, info_queue)
    localize{type = 'descriptions', key = card.config.card.name, set = 'MinorArcana', nodes = desc_nodes, vars = vars}
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''elseif self.name == 'The Ox' then'''
position = 'at'
payload = '''elseif (self.name == 'The Ox') and ((G.GAME.negate_hand or 1) >= 0) then'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''if self.name == 'The Arm' then'''
position = 'at'
payload = '''if (self.name == 'The Arm') and ((G.GAME.negate_hand or 1) >= 0) then'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''if #G.hand.cards < 1 and #G.deck.cards < 1 and #G.play.cards < 1 then
    end_round()'''
position = 'at'
payload = '''if #G.hand.cards < 1 and #G.deck.cards < 1 and #G.play.cards < 1 then
    if G.GAME.hit_reshuffle_deck and not G.GAME.hit_reshuffling then
        G.GAME.hit_reshuffling = true
        G.E_MANAGER:add_event(Event({
            trigger = 'immediate',
            func = function()
                for i = 1, #G.discard.cards do
                    draw_card(G.discard, G.deck, i*100/5, 'up')
                end
                G.E_MANAGER:add_event(Event({
                    trigger = 'immediate',
                    func = function()
                        G.deck:shuffle('player_deck')
                        G.GAME.hit_reshuffling = false
                        return true
                    end
                }))
                return true
            end
        }))
    elseif not G.GAME.hit_reshuffling then
        end_round()
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''if #G.hand.cards < 1 and #G.deck.cards < 1 then
            end_round()'''
position = 'at'
payload = '''if #G.hand.cards < 1 and #G.deck.cards < 1 then
    if G.GAME.hit_reshuffle_deck and not G.GAME.hit_reshuffling then
        G.GAME.hit_reshuffling = true
        G.E_MANAGER:add_event(Event({
            trigger = 'immediate',
            func = function()
                for i = 1, #G.discard.cards do
                    draw_card(G.discard, G.deck, i*100/5, 'up')
                end
                G.E_MANAGER:add_event(Event({
                    trigger = 'immediate',
                    func = function()
                        G.deck:shuffle('player_deck')
                        G.GAME.hit_reshuffling = false
                        return true
                    end
                }))
                return true
            end
        }))
    elseif not G.GAME.hit_reshuffling then
        end_round()
    end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''G.E_MANAGER:add_event(Event({
    trigger = 'ease',
    blocking = false,
    ref_table = G.GAME,
    ref_value = 'chips',
    ease_to = G.GAME.chips + math.floor(hand_chips*mult),
    delay =  0.5,
    func = (function(t) return math.floor(t) end)
}))'''
position = 'at'
payload = '''if not G.GAME.suits_drawn then
    G.E_MANAGER:add_event(Event({
        trigger = 'ease',
        blocking = false,
        ref_table = G.GAME,
        ref_value = 'chips',
        ease_to = G.GAME.chips + math.floor(hand_chips*mult),
        delay =  0.5,
        func = (function(t) return math.floor(t) end)
    }))
end'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''if center.consumeable then'''
position = 'before'
payload = '''if G and G.GAME and G.GAME.modifiers and G.GAME.modifiers.dungeon then
    local changes = {
        j_greedy_joker = {{'extra', 's_mult', 4}},
        j_lusty_joker = {{'extra', 's_mult', 4}},
        j_wrathful_joker = {{'extra', 's_mult', 4}},
        j_gluttenous_joker = {{'extra', 's_mult', 4}},
        j_8_ball = {{'extra', 3}},
        j_scary_face = {{'extra', 45}},
        j_even_steven = {{'extra', 6}},
        j_odd_todd = {{'extra', 49}},
        j_square = {{'extra', 'chip_mod', 16}},
        j_business = {{'extra', 4}},
        j_ancient = {{'extra', 2}},
        j_castle = {{'extra', 'chip_mod', 4}},
        j_smiley = {{'extra', 8}},
        j_rough_gem = {{'extra', 3}},
        j_bloodstone = {{'extra', 'odds', 1}},
        j_arrowhead = {{'extra', 75}},
        j_idol = {{'extra', 3}},
        j_triboulet = {{'extra', 3}},
    }
    if self.config.center.key and changes[self.config.center.key] then
        for i2, j2 in ipairs(changes[self.config.center.key]) do
            if #j2 == 2 then
                self.ability[j2[1]] = j2[2]
            else
                local the_table = self.ability
                for i3 = 1, #j2 - 2 do
                    the_table = the_table[j2[i3]]
                end
                the_table[j2[#j2 - 1]] = j2[#j2]
            end
        end
    end
end
'''
match_indent = true